// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package stamp

import (
	"fmt"
	"strings"
)

const (
	// ConflictConfigKeep is a ConflictConfig of type keep.
	ConflictConfigKeep ConflictConfig = "keep"
	// ConflictConfigReplace is a ConflictConfig of type replace.
	ConflictConfigReplace ConflictConfig = "replace"
	// ConflictConfigPrompt is a ConflictConfig of type prompt.
	ConflictConfigPrompt ConflictConfig = "prompt"
)

var ErrInvalidConflictConfig = fmt.Errorf("not a valid ConflictConfig, try [%s]", strings.Join(_ConflictConfigNames, ", "))

var _ConflictConfigNames = []string{
	string(ConflictConfigKeep),
	string(ConflictConfigReplace),
	string(ConflictConfigPrompt),
}

// ConflictConfigNames returns a list of possible string values of ConflictConfig.
func ConflictConfigNames() []string {
	tmp := make([]string, len(_ConflictConfigNames))
	copy(tmp, _ConflictConfigNames)
	return tmp
}

// String implements the Stringer interface.
func (x ConflictConfig) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x ConflictConfig) IsValid() bool {
	_, err := ParseConflictConfig(string(x))
	return err == nil
}

var _ConflictConfigValue = map[string]ConflictConfig{
	"keep":    ConflictConfigKeep,
	"replace": ConflictConfigReplace,
	"prompt":  ConflictConfigPrompt,
}

// ParseConflictConfig attempts to convert a string to a ConflictConfig.
func ParseConflictConfig(name string) (ConflictConfig, error) {
	if x, ok := _ConflictConfigValue[name]; ok {
		return x, nil
	}
	return ConflictConfig(""), fmt.Errorf("%s is %w", name, ErrInvalidConflictConfig)
}

// MarshalText implements the text marshaller method.
func (x ConflictConfig) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ConflictConfig) UnmarshalText(text []byte) error {
	tmp, err := ParseConflictConfig(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// FileTypeJson is a FileType of type json.
	FileTypeJson FileType = "json"
	// FileTypeYaml is a FileType of type yaml.
	FileTypeYaml FileType = "yaml"
	// FileTypeText is a FileType of type text.
	FileTypeText FileType = "text"
)

var ErrInvalidFileType = fmt.Errorf("not a valid FileType, try [%s]", strings.Join(_FileTypeNames, ", "))

var _FileTypeNames = []string{
	string(FileTypeJson),
	string(FileTypeYaml),
	string(FileTypeText),
}

// FileTypeNames returns a list of possible string values of FileType.
func FileTypeNames() []string {
	tmp := make([]string, len(_FileTypeNames))
	copy(tmp, _FileTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x FileType) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x FileType) IsValid() bool {
	_, err := ParseFileType(string(x))
	return err == nil
}

var _FileTypeValue = map[string]FileType{
	"json": FileTypeJson,
	"yaml": FileTypeYaml,
	"text": FileTypeText,
}

// ParseFileType attempts to convert a string to a FileType.
func ParseFileType(name string) (FileType, error) {
	if x, ok := _FileTypeValue[name]; ok {
		return x, nil
	}
	return FileType(""), fmt.Errorf("%s is %w", name, ErrInvalidFileType)
}

// MarshalText implements the text marshaller method.
func (x FileType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FileType) UnmarshalText(text []byte) error {
	tmp, err := ParseFileType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MatchSourceFile is a MatchSource of type file.
	MatchSourceFile MatchSource = "file"
	// MatchSourceLine is a MatchSource of type line.
	MatchSourceLine MatchSource = "line"
)

var ErrInvalidMatchSource = fmt.Errorf("not a valid MatchSource, try [%s]", strings.Join(_MatchSourceNames, ", "))

var _MatchSourceNames = []string{
	string(MatchSourceFile),
	string(MatchSourceLine),
}

// MatchSourceNames returns a list of possible string values of MatchSource.
func MatchSourceNames() []string {
	tmp := make([]string, len(_MatchSourceNames))
	copy(tmp, _MatchSourceNames)
	return tmp
}

// String implements the Stringer interface.
func (x MatchSource) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x MatchSource) IsValid() bool {
	_, err := ParseMatchSource(string(x))
	return err == nil
}

var _MatchSourceValue = map[string]MatchSource{
	"file": MatchSourceFile,
	"line": MatchSourceLine,
}

// ParseMatchSource attempts to convert a string to a MatchSource.
func ParseMatchSource(name string) (MatchSource, error) {
	if x, ok := _MatchSourceValue[name]; ok {
		return x, nil
	}
	return MatchSource(""), fmt.Errorf("%s is %w", name, ErrInvalidMatchSource)
}

// MarshalText implements the text marshaller method.
func (x MatchSource) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MatchSource) UnmarshalText(text []byte) error {
	tmp, err := ParseMatchSource(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MissingConfigIgnore is a MissingConfig of type ignore.
	MissingConfigIgnore MissingConfig = "ignore"
	// MissingConfigTouch is a MissingConfig of type touch.
	MissingConfigTouch MissingConfig = "touch"
	// MissingConfigError is a MissingConfig of type error.
	MissingConfigError MissingConfig = "error"
)

var ErrInvalidMissingConfig = fmt.Errorf("not a valid MissingConfig, try [%s]", strings.Join(_MissingConfigNames, ", "))

var _MissingConfigNames = []string{
	string(MissingConfigIgnore),
	string(MissingConfigTouch),
	string(MissingConfigError),
}

// MissingConfigNames returns a list of possible string values of MissingConfig.
func MissingConfigNames() []string {
	tmp := make([]string, len(_MissingConfigNames))
	copy(tmp, _MissingConfigNames)
	return tmp
}

// String implements the Stringer interface.
func (x MissingConfig) String() string {
	return string(x)
}

// String implements the Stringer interface.
func (x MissingConfig) IsValid() bool {
	_, err := ParseMissingConfig(string(x))
	return err == nil
}

var _MissingConfigValue = map[string]MissingConfig{
	"ignore": MissingConfigIgnore,
	"touch":  MissingConfigTouch,
	"error":  MissingConfigError,
}

// ParseMissingConfig attempts to convert a string to a MissingConfig.
func ParseMissingConfig(name string) (MissingConfig, error) {
	if x, ok := _MissingConfigValue[name]; ok {
		return x, nil
	}
	return MissingConfig(""), fmt.Errorf("%s is %w", name, ErrInvalidMissingConfig)
}

// MarshalText implements the text marshaller method.
func (x MissingConfig) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MissingConfig) UnmarshalText(text []byte) error {
	tmp, err := ParseMissingConfig(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
