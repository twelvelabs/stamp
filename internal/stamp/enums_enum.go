// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package stamp

import (
	"fmt"
	"strings"

	"github.com/swaggest/jsonschema-go"
)

const (
	// Keep the existing path. The task becomes a noop.
	ConflictConfigKeep ConflictConfig = "keep"
	// Replace the existing path.
	ConflictConfigReplace ConflictConfig = "replace"
	// Prompt the user.
	ConflictConfigPrompt ConflictConfig = "prompt"
)

var ErrInvalidConflictConfig = fmt.Errorf("not a valid ConflictConfig, try [%s]", strings.Join(_ConflictConfigNames, ", "))

var _ConflictConfigNames = []string{
	string(ConflictConfigKeep),
	string(ConflictConfigReplace),
	string(ConflictConfigPrompt),
}

// ConflictConfigNames returns a list of possible string values of ConflictConfig.
func ConflictConfigNames() []string {
	tmp := make([]string, len(_ConflictConfigNames))
	copy(tmp, _ConflictConfigNames)
	return tmp
}

// String implements the Stringer interface.
func (x ConflictConfig) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ConflictConfig) IsValid() bool {
	_, err := ParseConflictConfig(string(x))
	return err == nil
}

var _ConflictConfigValue = map[string]ConflictConfig{
	"keep":    ConflictConfigKeep,
	"replace": ConflictConfigReplace,
	"prompt":  ConflictConfigPrompt,
}

// ParseConflictConfig attempts to convert a string to a ConflictConfig.
func ParseConflictConfig(name string) (ConflictConfig, error) {
	if x, ok := _ConflictConfigValue[name]; ok {
		return x, nil
	}
	return ConflictConfig(""), fmt.Errorf("%s is %w", name, ErrInvalidConflictConfig)
}

// MarshalText implements the text marshaller method.
func (x ConflictConfig) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ConflictConfig) UnmarshalText(text []byte) error {
	tmp, err := ParseConflictConfig(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var (
	_ jsonschema.Described = ConflictConfig("")
	_ jsonschema.Enum      = ConflictConfig("")
	_ jsonschema.Preparer  = ConflictConfig("")
)

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x ConflictConfig) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithTitle("ConflictConfig")
	schema.WithDescription(x.Description())
	schema.WithEnum(x.Enum()...)
	schema.WithExtraPropertiesItem("enumDescriptions", x.EnumComments())
	return nil
}

// Enum implements the jsonschema.Described interface.
func (x ConflictConfig) Description() string {
	return `Determines what to do when creating a new file and
the destination path already exists.

> [!IMPORTANT]
> Only used in [create] tasks.

[create]: https://github.com/twelvelabs/stamp/tree/main/docs/create_task.md`
}

// Enum implements the jsonschema.Enum interface.
func (x ConflictConfig) Enum() []any {
	return []any{
		"keep",
		"replace",
		"prompt",
	}
}

// EnumComments returns the comment associated with each enum.
func (x ConflictConfig) EnumComments() []string {
	return []string{
		"Keep the existing path. The task becomes a noop.",
		"Replace the existing path.",
		"Prompt the user.",
	}
}

const (
	FileTypeJson FileType = "json"
	FileTypeYaml FileType = "yaml"
	FileTypeText FileType = "text"
)

var ErrInvalidFileType = fmt.Errorf("not a valid FileType, try [%s]", strings.Join(_FileTypeNames, ", "))

var _FileTypeNames = []string{
	string(FileTypeJson),
	string(FileTypeYaml),
	string(FileTypeText),
}

// FileTypeNames returns a list of possible string values of FileType.
func FileTypeNames() []string {
	tmp := make([]string, len(_FileTypeNames))
	copy(tmp, _FileTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x FileType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FileType) IsValid() bool {
	_, err := ParseFileType(string(x))
	return err == nil
}

var _FileTypeValue = map[string]FileType{
	"json": FileTypeJson,
	"yaml": FileTypeYaml,
	"text": FileTypeText,
}

// ParseFileType attempts to convert a string to a FileType.
func ParseFileType(name string) (FileType, error) {
	if x, ok := _FileTypeValue[name]; ok {
		return x, nil
	}
	return FileType(""), fmt.Errorf("%s is %w", name, ErrInvalidFileType)
}

// MarshalText implements the text marshaller method.
func (x FileType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FileType) UnmarshalText(text []byte) error {
	tmp, err := ParseFileType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var (
	_ jsonschema.Described = FileType("")
	_ jsonschema.Enum      = FileType("")
	_ jsonschema.Preparer  = FileType("")
)

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x FileType) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithTitle("FileType")
	schema.WithDescription(x.Description())
	schema.WithEnum(x.Enum()...)
	schema.WithExtraPropertiesItem("enumDescriptions", x.EnumComments())
	return nil
}

// Enum implements the jsonschema.Described interface.
func (x FileType) Description() string {
	return `Specifies the content type of the file.
Inferred from the file extension by default.

When the content type is JSON or YAML, the file will be
parsed into a data structure before use.
When updating files, the content type determines
the behavior of the [match.pattern] attribute.

[match.pattern]: https://github.com/twelvelabs/stamp/tree/main/docs/match.md#pattern`
}

// Enum implements the jsonschema.Enum interface.
func (x FileType) Enum() []any {
	return []any{
		"json",
		"yaml",
		"text",
	}
}

// EnumComments returns the comment associated with each enum.
func (x FileType) EnumComments() []string {
	return []string{
		"",
		"",
		"",
	}
}

const (
	// Match the entire file.
	MatchSourceFile MatchSource = "file"
	// Match each line.
	MatchSourceLine MatchSource = "line"
)

var ErrInvalidMatchSource = fmt.Errorf("not a valid MatchSource, try [%s]", strings.Join(_MatchSourceNames, ", "))

var _MatchSourceNames = []string{
	string(MatchSourceFile),
	string(MatchSourceLine),
}

// MatchSourceNames returns a list of possible string values of MatchSource.
func MatchSourceNames() []string {
	tmp := make([]string, len(_MatchSourceNames))
	copy(tmp, _MatchSourceNames)
	return tmp
}

// String implements the Stringer interface.
func (x MatchSource) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MatchSource) IsValid() bool {
	_, err := ParseMatchSource(string(x))
	return err == nil
}

var _MatchSourceValue = map[string]MatchSource{
	"file": MatchSourceFile,
	"line": MatchSourceLine,
}

// ParseMatchSource attempts to convert a string to a MatchSource.
func ParseMatchSource(name string) (MatchSource, error) {
	if x, ok := _MatchSourceValue[name]; ok {
		return x, nil
	}
	return MatchSource(""), fmt.Errorf("%s is %w", name, ErrInvalidMatchSource)
}

// MarshalText implements the text marshaller method.
func (x MatchSource) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MatchSource) UnmarshalText(text []byte) error {
	tmp, err := ParseMatchSource(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var (
	_ jsonschema.Described = MatchSource("")
	_ jsonschema.Enum      = MatchSource("")
	_ jsonschema.Preparer  = MatchSource("")
)

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x MatchSource) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithTitle("MatchSource")
	schema.WithDescription(x.Description())
	schema.WithEnum(x.Enum()...)
	schema.WithExtraPropertiesItem("enumDescriptions", x.EnumComments())
	return nil
}

// Enum implements the jsonschema.Described interface.
func (x MatchSource) Description() string {
	return `Determines how regexp patterns should be applied.`
}

// Enum implements the jsonschema.Enum interface.
func (x MatchSource) Enum() []any {
	return []any{
		"file",
		"line",
	}
}

// EnumComments returns the comment associated with each enum.
func (x MatchSource) EnumComments() []string {
	return []string{
		"Match the entire file.",
		"Match each line.",
	}
}

const (
	// Do nothing. The task becomes a noop.
	MissingConfigIgnore MissingConfig = "ignore"
	// Create an empty file.
	MissingConfigTouch MissingConfig = "touch"
	// Raise an error.
	MissingConfigError MissingConfig = "error"
)

var ErrInvalidMissingConfig = fmt.Errorf("not a valid MissingConfig, try [%s]", strings.Join(_MissingConfigNames, ", "))

var _MissingConfigNames = []string{
	string(MissingConfigIgnore),
	string(MissingConfigTouch),
	string(MissingConfigError),
}

// MissingConfigNames returns a list of possible string values of MissingConfig.
func MissingConfigNames() []string {
	tmp := make([]string, len(_MissingConfigNames))
	copy(tmp, _MissingConfigNames)
	return tmp
}

// String implements the Stringer interface.
func (x MissingConfig) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MissingConfig) IsValid() bool {
	_, err := ParseMissingConfig(string(x))
	return err == nil
}

var _MissingConfigValue = map[string]MissingConfig{
	"ignore": MissingConfigIgnore,
	"touch":  MissingConfigTouch,
	"error":  MissingConfigError,
}

// ParseMissingConfig attempts to convert a string to a MissingConfig.
func ParseMissingConfig(name string) (MissingConfig, error) {
	if x, ok := _MissingConfigValue[name]; ok {
		return x, nil
	}
	return MissingConfig(""), fmt.Errorf("%s is %w", name, ErrInvalidMissingConfig)
}

// MarshalText implements the text marshaller method.
func (x MissingConfig) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MissingConfig) UnmarshalText(text []byte) error {
	tmp, err := ParseMissingConfig(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var (
	_ jsonschema.Described = MissingConfig("")
	_ jsonschema.Enum      = MissingConfig("")
	_ jsonschema.Preparer  = MissingConfig("")
)

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x MissingConfig) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithTitle("MissingConfig")
	schema.WithDescription(x.Description())
	schema.WithEnum(x.Enum()...)
	schema.WithExtraPropertiesItem("enumDescriptions", x.EnumComments())
	return nil
}

// Enum implements the jsonschema.Described interface.
func (x MissingConfig) Description() string {
	return `Determines what to do when updating an existing file and
the destination path is missing.

> [!IMPORTANT]
> Only used in [update] and [delete] tasks.

[update]: https://github.com/twelvelabs/stamp/tree/main/docs/update_task.md
[delete]: https://github.com/twelvelabs/stamp/tree/main/docs/delete_task.md`
}

// Enum implements the jsonschema.Enum interface.
func (x MissingConfig) Enum() []any {
	return []any{
		"ignore",
		"touch",
		"error",
	}
}

// EnumComments returns the comment associated with each enum.
func (x MissingConfig) EnumComments() []string {
	return []string{
		"Do nothing. The task becomes a noop.",
		"Create an empty file.",
		"Raise an error.",
	}
}

const (
	// Callable anywhere.
	VisibilityTypePublic VisibilityType = "public"
	// Public, but hidden in the generator list.
	VisibilityTypeHidden VisibilityType = "hidden"
	// Only callable as a sub-generator. Never displayed.
	VisibilityTypePrivate VisibilityType = "private"
)

var ErrInvalidVisibilityType = fmt.Errorf("not a valid VisibilityType, try [%s]", strings.Join(_VisibilityTypeNames, ", "))

var _VisibilityTypeNames = []string{
	string(VisibilityTypePublic),
	string(VisibilityTypeHidden),
	string(VisibilityTypePrivate),
}

// VisibilityTypeNames returns a list of possible string values of VisibilityType.
func VisibilityTypeNames() []string {
	tmp := make([]string, len(_VisibilityTypeNames))
	copy(tmp, _VisibilityTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x VisibilityType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VisibilityType) IsValid() bool {
	_, err := ParseVisibilityType(string(x))
	return err == nil
}

var _VisibilityTypeValue = map[string]VisibilityType{
	"public":  VisibilityTypePublic,
	"hidden":  VisibilityTypeHidden,
	"private": VisibilityTypePrivate,
}

// ParseVisibilityType attempts to convert a string to a VisibilityType.
func ParseVisibilityType(name string) (VisibilityType, error) {
	if x, ok := _VisibilityTypeValue[name]; ok {
		return x, nil
	}
	return VisibilityType(""), fmt.Errorf("%s is %w", name, ErrInvalidVisibilityType)
}

// MarshalText implements the text marshaller method.
func (x VisibilityType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *VisibilityType) UnmarshalText(text []byte) error {
	tmp, err := ParseVisibilityType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var (
	_ jsonschema.Described = VisibilityType("")
	_ jsonschema.Enum      = VisibilityType("")
	_ jsonschema.Preparer  = VisibilityType("")
)

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x VisibilityType) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithTitle("VisibilityType")
	schema.WithDescription(x.Description())
	schema.WithEnum(x.Enum()...)
	schema.WithExtraPropertiesItem("enumDescriptions", x.EnumComments())
	return nil
}

// Enum implements the jsonschema.Described interface.
func (x VisibilityType) Description() string {
	return `Determines the visibility of the generator.`
}

// Enum implements the jsonschema.Enum interface.
func (x VisibilityType) Enum() []any {
	return []any{
		"public",
		"hidden",
		"private",
	}
}

// EnumComments returns the comment associated with each enum.
func (x VisibilityType) EnumComments() []string {
	return []string{
		"Callable anywhere.",
		"Public, but hidden in the generator list.",
		"Only callable as a sub-generator. Never displayed.",
	}
}
