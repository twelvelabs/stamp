// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package value

import (
	"fmt"
	"strings"

	"github.com/swaggest/jsonschema-go"
)

const (
	// DataTypeBool is a DataType of type bool.
	DataTypeBool DataType = "bool"
	// DataTypeInt is a DataType of type int.
	DataTypeInt DataType = "int"
	// DataTypeIntSlice is a DataType of type intSlice.
	DataTypeIntSlice DataType = "intSlice"
	// DataTypeString is a DataType of type string.
	DataTypeString DataType = "string"
	// DataTypeStringSlice is a DataType of type stringSlice.
	DataTypeStringSlice DataType = "stringSlice"
)

var ErrInvalidDataType = fmt.Errorf("not a valid DataType, try [%s]", strings.Join(_DataTypeNames, ", "))

var _DataTypeNames = []string{
	string(DataTypeBool),
	string(DataTypeInt),
	string(DataTypeIntSlice),
	string(DataTypeString),
	string(DataTypeStringSlice),
}

// DataTypeNames returns a list of possible string values of DataType.
func DataTypeNames() []string {
	tmp := make([]string, len(_DataTypeNames))
	copy(tmp, _DataTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x DataType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DataType) IsValid() bool {
	_, err := ParseDataType(string(x))
	return err == nil
}

var _DataTypeValue = map[string]DataType{
	"bool":        DataTypeBool,
	"int":         DataTypeInt,
	"intSlice":    DataTypeIntSlice,
	"string":      DataTypeString,
	"stringSlice": DataTypeStringSlice,
}

// ParseDataType attempts to convert a string to a DataType.
func ParseDataType(name string) (DataType, error) {
	if x, ok := _DataTypeValue[name]; ok {
		return x, nil
	}
	return DataType(""), fmt.Errorf("%s is %w", name, ErrInvalidDataType)
}

// MarshalText implements the text marshaller method.
func (x DataType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DataType) UnmarshalText(text []byte) error {
	tmp, err := ParseDataType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var _ jsonschema.Preparer = DataType("")

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x DataType) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithDescription("DataType enum.")
	schema.WithEnum(x.Enum()...)
	return nil
}

// Enum implements the jsonschema.Enum interface.
func (x DataType) Enum() []any {
	return []any{
		"bool",
		"int",
		"intSlice",
		"string",
		"stringSlice",
	}
}

const (
	// InputModeArg is a InputMode of type arg.
	InputModeArg InputMode = "arg"
	// InputModeFlag is a InputMode of type flag.
	InputModeFlag InputMode = "flag"
	// InputModeHidden is a InputMode of type hidden.
	InputModeHidden InputMode = "hidden"
)

var ErrInvalidInputMode = fmt.Errorf("not a valid InputMode, try [%s]", strings.Join(_InputModeNames, ", "))

var _InputModeNames = []string{
	string(InputModeArg),
	string(InputModeFlag),
	string(InputModeHidden),
}

// InputModeNames returns a list of possible string values of InputMode.
func InputModeNames() []string {
	tmp := make([]string, len(_InputModeNames))
	copy(tmp, _InputModeNames)
	return tmp
}

// String implements the Stringer interface.
func (x InputMode) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x InputMode) IsValid() bool {
	_, err := ParseInputMode(string(x))
	return err == nil
}

var _InputModeValue = map[string]InputMode{
	"arg":    InputModeArg,
	"flag":   InputModeFlag,
	"hidden": InputModeHidden,
}

// ParseInputMode attempts to convert a string to a InputMode.
func ParseInputMode(name string) (InputMode, error) {
	if x, ok := _InputModeValue[name]; ok {
		return x, nil
	}
	return InputMode(""), fmt.Errorf("%s is %w", name, ErrInvalidInputMode)
}

// MarshalText implements the text marshaller method.
func (x InputMode) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *InputMode) UnmarshalText(text []byte) error {
	tmp, err := ParseInputMode(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var _ jsonschema.Preparer = InputMode("")

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x InputMode) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithDescription("InputMode enum.")
	schema.WithEnum(x.Enum()...)
	return nil
}

// Enum implements the jsonschema.Enum interface.
func (x InputMode) Enum() []any {
	return []any{
		"arg",
		"flag",
		"hidden",
	}
}

const (
	// PromptConfigAlways is a PromptConfig of type always.
	PromptConfigAlways PromptConfig = "always"
	// PromptConfigNever is a PromptConfig of type never.
	PromptConfigNever PromptConfig = "never"
	// PromptConfigOnEmpty is a PromptConfig of type on-empty.
	PromptConfigOnEmpty PromptConfig = "on-empty"
	// PromptConfigOnUnset is a PromptConfig of type on-unset.
	PromptConfigOnUnset PromptConfig = "on-unset"
)

var ErrInvalidPromptConfig = fmt.Errorf("not a valid PromptConfig, try [%s]", strings.Join(_PromptConfigNames, ", "))

var _PromptConfigNames = []string{
	string(PromptConfigAlways),
	string(PromptConfigNever),
	string(PromptConfigOnEmpty),
	string(PromptConfigOnUnset),
}

// PromptConfigNames returns a list of possible string values of PromptConfig.
func PromptConfigNames() []string {
	tmp := make([]string, len(_PromptConfigNames))
	copy(tmp, _PromptConfigNames)
	return tmp
}

// String implements the Stringer interface.
func (x PromptConfig) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PromptConfig) IsValid() bool {
	_, err := ParsePromptConfig(string(x))
	return err == nil
}

var _PromptConfigValue = map[string]PromptConfig{
	"always":   PromptConfigAlways,
	"never":    PromptConfigNever,
	"on-empty": PromptConfigOnEmpty,
	"on-unset": PromptConfigOnUnset,
}

// ParsePromptConfig attempts to convert a string to a PromptConfig.
func ParsePromptConfig(name string) (PromptConfig, error) {
	if x, ok := _PromptConfigValue[name]; ok {
		return x, nil
	}
	return PromptConfig(""), fmt.Errorf("%s is %w", name, ErrInvalidPromptConfig)
}

// MarshalText implements the text marshaller method.
func (x PromptConfig) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *PromptConfig) UnmarshalText(text []byte) error {
	tmp, err := ParsePromptConfig(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var _ jsonschema.Preparer = PromptConfig("")

// PrepareJSONSchema implements the jsonschema.Preparer interface.
func (x PromptConfig) PrepareJSONSchema(schema *jsonschema.Schema) error {
	schema.WithDescription("PromptConfig enum.")
	schema.WithEnum(x.Enum()...)
	return nil
}

// Enum implements the jsonschema.Enum interface.
func (x PromptConfig) Enum() []any {
	return []any{
		"always",
		"never",
		"on-empty",
		"on-unset",
	}
}
